from math_verify import parse, verify
from typing import List
import re
def accuracy_reward(
        completions,
        solution,
        **kwargs
) -> List[float]:
    """
    Reward function that checks if the completion is correct either using symbolic matching (using math-verify) or string based matching.
    Args:
        completions: The completions generated by the model.
        solution: The ground truth solution.
        **kwargs: Other key word arugments.
    Returns:
        Reward vector (List[float])
    """
    contents = [completion[0]['content'] for completion in completions]
    rewards = []

    for content, sol in zip(contents, solution):
        reward = 0.0
        try:
            answer = parse(content)
            if float(verify(answer, parse(sol))) > 0:
                reward = 1.0
        except Exception:
            pass

        if reward == 0.0:
            try:
                sol_match = re.search(r'<answer>(.*?)</answer>', sol)
                ground_truth = sol_match.group(1).strip() if sol_match else sol.strip()

                content_match = re.search(r'<answer>(.*?)</answer>', content)
                student_answer = content_match.group(1).strip() if content_match else content.strip()
                
                #Compare the extracted answers
                if student_answer == ground_truth:
                    reward = 1.0
            except Exception:
                pass  #Keep reward as 0.0 if both methods fail
        rewards.append(reward)
    return rewards